---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# TSLC

<!-- badges: start -->
<!-- badges: end -->

The goal of TSLC is to take into account information on both the taxa and genes/gene pathways in order to find differentially abundant taxa that are associated with a potential difference in function across two populations of interest. This is a two-stage approach that looks at differences in function across the population in the first stage, and then looks at differences in the taxa associated with each differentially abundant function in the second stage.

## Installation

You can install the development version of TSLC like so:

``` r
install_github(repo = "rgbeblavy/TSLC")
```

## Example

Here, we will illustrate how to use this package to implement the two-stagewise approach to find differentially abundant taxa given differentially abundant functions. For the ease of illustration, we use a very low-dimensional data set consisting of 10 subjects, 10 taxa, and 5 gene pathways.

First, we will load in the file 'wmg_demo_data.csv', which gives synthetic data on the functions, as well as the taxa contributing to each function. In this data frame, the rows that do not have a vertical bar "|" give the aggregated abundances of each of the synthetic pathways, while the rows with a vertical bar tell us the contribution of the taxon to each function. The following chunk of code loads this file.

```{r example}
library(tidyverse)
library(TSLC)

wmg.dat <- read.csv(file = "wmg_demo_data.csv", header = TRUE)
wmg.dat[,1] <- NULL # Remove the index column
print(wmg.dat)
```


Now, we just need a data frame that contains the outcome and any covariates of interest for each of the subjects. We will store this information in the variable 'meta.data'. Note that the names in the SampleID column correspond to the column names in the previous data frame. For illustration purposes, we randomly generate this dataset. However, this would be obtained from real data in practice.

```{r}
set.seed(2025)
y <- c(rep(1,5), rep(0,5)) # response variable
x <- rnorm(n = 10, mean = 0, sd = 1) # covariate

meta.data <- data.frame("SampleID" = colnames(wmg.dat)[-1],
                        "y" = y,
                        "X" = x)
print(meta.data)
```

Finally, we can use these quantities to identify the BRp taxa for this dataset. We will run the two-stagewise procedure and assign a variable for each part of the output.

```{r}
res <- get.brp.taxa(wmgs.dat = wmg.dat, meta.dat = meta.data)
fun.res <- res$fun.res
tax.res <- res$tax.res
brp.tax <- res$brp.tax
```

Let's first examine the output from the first stage where we identify DA functions. The table below displays the results from the first stage. The column "Est" gives the estimated regression coefficient after running the debiasing procedure, the column "SD" gives the standard deviation, the column "pval" gives the nominal p-value, and the column "adjp" gives the p-value after correcting for multiple comparisons. We can determine statistical significance by looking at which functions have an adjusted p-value below a certain threshold. By default, our R package considers a function to be DA if it has an adjusted p-value below 0.10. Therefore, 'pwy5' is the only DA function in the first stage.

```{r}
print(fun.res)
```

Now, let's examine the result from the second stage. The output below displays the list containing these results. Since 'pwy5' was the only DA function, we only run the second stage for 'pwy5' and all the taxa contributing to it. From the earlier data frame, only species G, H, I, and J are linked to this pathway. Therefore, the second stage looks at this subcomposition of taxa and runs a log contrast model to determine which are BRp taxa. From the output below, only species J has an adjusted p-value below 0.10, so species J is the only BRp taxon conditional on the function 'pwy5'.

```{r}
print(tax.res)
```

Finally, let's print out all identified BRp taxa along with their associated functions. This is stored in the variable 'brp.tax'.

```{r}
print(brp.tax)
```



