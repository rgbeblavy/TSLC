library(daTaxa)
library(TSLC)
?two.stage.da.analyiss
?two.stage.da.analysis
library(TSLC)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
library(tidyverse)
library(daTaxa)
metaphlan.out <- read.csv(file = "tax_prof_demo.csv", header = TRUE)
rownames(metaphlan.out) <- metaphlan.out[,1]
metaphlan.out[,1] <- NULL
head(metaphlan.out)
humann.out <- read.csv(file = "functional_prof_demo.csv", header = TRUE)
humann.out[,1] <- NULL # Remove the index column
head(humann.out)
Fjs <- get.taxa(humann.out)
print(Fjs)
humann.out.t <- humann.out %>%
dplyr::filter(!grepl("|", X..Pathway, fixed = TRUE)) # Select only pathways giving total counts
pwy_names <- humann.out.t$X..Pathway
rownames(humann.out.t) <- pwy_names
humann.out.t <- humann.out.t %>%
dplyr::select(-X..Pathway) %>%
t() %>%
as.matrix() # Must be a matrix to run the function for the two-stagewise method
print(humann.out.t)
#humann.out.t <- transform(humann.out.t, as.numeric()) # Ensure that we have numerics
humann.out.t <- humann.out.t + 0.5 # Add pseudocount
humann.out.t <- proportions(humann.out.t, margin = 1) # Convert to proportions
print(humann.out.t)
metaphlan.out <- as.matrix(metaphlan.out) # Must have a matrix to run the function for the two-stagewise method
metaphlan.out <- metaphlan.out + .5 # Add pseudocount
metaphlan.out <- proportions(metaphlan.out, margin = 1) # Convert to proportions
print(metaphlan.out)
meta.dat <- read.csv(file = "meta_dat_demo.csv", header = TRUE)
meta.dat[,1] <- NULL # Remove the index column since it's redundant
head(meta.dat)
y <- meta.dat[,"Group"] %>% as.vector()
X <- meta.dat[,"Covariate"] %>% as.matrix()
res <- two.stage.da.analysis(y = y, fun_prof = humann.out.t, tax_prof = metaphlan.out, Fjs = Fjs, x = X)
print(res)
